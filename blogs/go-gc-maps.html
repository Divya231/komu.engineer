<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Komu W - blog.</title>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ADD FAVICON -->

    <style>
        /*
         styled using css-grid:
         https://css-tricks.com/snippets/css/complete-guide-grid/
         */

        @media (max-width: 720px) {
            /* applies if your viewport width is equal to or less than 720px */
            .container {
                grid-template-columns: [column1-start] 1fr [column1-end] 10fr [column2-end] 1fr [column3-end];
            }
            pre {
                margin-left: -62%;
            }
        }

        @media (min-width: 721px) {
            .container {
                grid-template-columns: [column1-start] 2fr [column1-end] 8fr [column2-end] 2fr [column3-end];
            }
            pre {
                margin-left: -15%;
            }
        }

        .container {
            /* grid | inline-grid | subgrid; */
            display: grid;

            grid-template-rows: [row1-start] auto [row1-end] auto [row2-end] auto [row3-end];
            grid-template-areas: "header header header" "left-sidebar main right-sidebar" ". . .";

            /* this two may not be needed */
            grid-column-gap: 1px;
            grid-row-gap: 1px;

            /* start | end | center | stretch; */
            /* align, content inside a grid item, along horizontal ie to the left or right */
            justify-items: center;

            /* start | end | center | stretch; */
            /* align, content inside a grid item, top or bottom */
            align-items: center;

            /* start | end | center | stretch | space-around | space-between | space-evenly; */
            /* sets the alignment of the grid within the grid container. left or right.
                esp if ua grid is less than the size of its grid container*/
            justify-content: stretch;

            /* start | end | center | stretch | space-around | space-between | space-evenly; */
            /* sets the alignment of the grid within the grid container. top or bottom.
                esp if ua grid is less than the size of its grid container*/
            align-content: stretch;


        }

        .item-header {
            grid-area: header;

            grid-column-start: column1-start;
            grid-column-end: column3-end;
            grid-row-start: row1-start;
            grid-row-end: row1-end;
        }

        .item-left-sidebar {
            grid-area: left-sidebar;

            grid-column-start: column1-start;
            grid-column-end: column1-end;
            grid-row-start: row1-end;
            grid-row-end: auto;

            justify-self: center;
        }

        .item-main {
            grid-area: main;

            grid-column-start: column1-end;
            grid-column-end: column2-end;
            grid-row-start: row1-end;
            grid-row-end: auto;

            /* start | end | center | stretch; */
            /* Aligns the content inside a grid item left to right */
            justify-self: center;
            /* start | end | center | stretch; */
            /* aligns top bottom */
            align-self: start;

            /* https://developer.mozilla.org/en-US/docs/Web/CSS/overflow */
            max-width: 100%;
            overflow: auto;
        }

        .item-right-sidebar {
            grid-area: right-sidebar;

            grid-column-start: column2-end;
            grid-column-end: column3-end;
            grid-row-start: row1-end;
            grid-row-end: auto;

            justify-self: center;
        }

        pre.prettyprint {
            padding: 2px;
            border: 0px !important;
        }
    </style>

    <!-- Get highlightjs by going to https://highlightjs.org/download/, select the languages you want and download. -->
    <link rel="stylesheet" href="../highlightjs/styles/default.css">
    <script src="../highlightjs/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <div class="container">
        <div class="item-header">
            <a href="https://www.komu.engineer">Home</a>&nbsp;&nbsp;
            <a href="https://www.komu.engineer/about">About Me</a>&nbsp;&nbsp;
            <a href="https://www.komu.engineer/blog">Blog</a>&nbsp;&nbsp;
        </div>
        <div class="item-left-sidebar">
            .
        </div>
        <div class="item-right-sidebar">
            .
        </div>

        <div class="item-main">
            <p>
                <strong> Go GC and maps with pointers.(25 Jan 2018)</strong>
                </br>
                </br>
                The other day I read a blog post titled
                <a target="_blank" rel="noopener" href="https://syslog.ravelin.com/gc-is-bad-and-you-should-feel-bad-e9bdd9324f0">GC is bad and you should feel bad</a> by
                <a target="_blank" rel="noopener" href="https://twitter.com/philpearl">@philpearl.</a> It's a well written blogpost and I would welcome you to go read it.
                </br>
                In it he says:</br>
                <q>In our ML fraud scoring pipeline we have a huge (>5GB) table of pre-calculated probabilities that we kept
                    in Go map[string]X in RAM. </br>
                    Recently we’d seen high GC pause times, corresponding with high 95th percentile response time peaks on our API.</br>
                    Once we’d moved the allocations off-heap into a custom hash-map backed by mmap allocated memory,.., the GC pauses practically
                    disappeared.
                </q>
                </br>
                </br>

                Soon after, I saw a tweet by
                <a target="_blank" rel="noopener" href="https://twitter.com/dgryski">Damian Gryski,</a> (if you are on twitter and love Go, then I would highly recommend you follow Damian)
                </br>
                In the tweet, he suggested that a minimum perfect hash function can be created to be used in place of the string keys to
                the map thus reducing GC times.</br>
                I was curious as to how using a hash would help to relieve the pressure on the garbage collector.</br>
                So, I set out to profile the GC times; first when you have a map whose keys are strings and second when you have a map whose
                keys are strings that have been hashed into ints.</br>
                </br>

                The program I used to profile that is:</br>
                <pre><code class="go">
                    package main
                    import (
                        "strconv"
                        "fmt"
                        "os"
                        "runtime"
                        "time"
                    )
                    // run this program as:
                    /*
                    #!/bin/bash
                    for t in 1 2; do go run gctest.go $t; done
                    */          
                    
                    func timeGC() time.Duration {
                        start := time.Now()
                        runtime.GC()
                        return time.Since(start)
                    }

                    func main() {
                        const N = 30e6
                        if len(os.Args) != 2 {
                            fmt.Printf("usage: %s [1 2]\n(number selects the test)\n", os.Args[0])
                            return
                        }
                        switch os.Args[1] {
                        case "1":
                            // create a big map of strings. since strings contain pointers, 
                            // we expect this to have more pressure on GC.
                            m := make(map[string]string)
                            for i := 0; i < N; i++ {
                                n := strconv.Itoa(i)
                                m[n] = n
                            }
                            runtime.GC()
                            fmt.Printf("With a map of strings, GC took: %s\n", timeGC())
                            _ = m["0"]
                        case "2":
                            // create a map of ints. We want to store strings in the map but unlike in case 1, 
                            // we will hash the strings to ints (which have no pointer)
                            // so we expect less pressure on GC. We are using  strconv.Atoi(str) 
                            // as a stand-in for a proper hash function
                            m := make(map[int]int)
                            for i := 0; i < N; i++ {
                                str := strconv.Itoa(i)
                                // hash string to int
                                n,_ := strconv.Atoi(str)
                                m[n] = n
                            }
                            runtime.GC()
                            fmt.Printf("With map of strings(that are hashed to ints), GC took:: %s\n", timeGC())
                            _ = m[0]
                        }
                    }
                 </code></pre>
                </br>
                </br>
                On running it, the results were;</br>
                <i>
                    With a map of strings, GC took:: 775.280442ms</br>
                    With map of strings(that are hashed to ints), GC took:: 19.086413ms
                </i>
                </br>
                </br>

                For the map whose keys are strings(ie *pointers) the Garbage collector ran for 775.2ms on my machine, while for the other
                map whose keys are strings that have been hashed into ints the GC ran for 19ms.</br>
                NB: Note that I used
                <i>strconv.Atoi(str)</i> in place of a proper string to integer hash function. In practice, you would be using
                <a target="_blank" rel="noopener" href="https://godoc.org/?q=mph">a proper hash implementation</a>
                </br>
                </br>

                That contrast is much more clear when visualized, So I used
                <a target="_blank" rel="noopener" href="https://github.com/davecheney/gcvis">Dave Cheney's gcvis</a> program to visualize the programs GC trace data.</br>
                The results are as shown below:</br>
                </br>

                GC profile of a creating a large Go map whose keys are strings;</br>
                <img src="../imgs/string[string].png" alt="map with string keys GC profile" style="width:800px;height:220px;">
                </br>

                GC profile of a creating a large Go map whose keys are ints(ie keys are strings that are hashed into ints);</br>
                <img src="../imgs/int[int].png" alt="map with string keys hashed to ints GC profile" style="width:800px;height:220px;">

                </br>
                </br>
                In conclusion; </br>
                (a) The Go Garbage collector is
                <a target="_blank" rel="noopener" href="https://blog.golang.org/go15gc">designed</a> to
                <a target="_blank" rel="noopener" href="https://blog.golang.org/go15gc">minimise</a> latencies. </br>
                (b) And it seems like one of the things that can cause the Garbage collector to have long pause times are large maps that
                have strings(any pointer really) as keys.</br>
                (c) And it seems like one of the ways to solve the issue in (b) above is to hash the strings into ints and then using the
                ints as keys, (You would of course have
                <a target="_blank" rel="noopener" href="https://github.com/dgryski/go-mph/blob/0a5ec2a4fe0d4b43b522f13c59b2a74979a91172/mph.go#L114-L125">methods to Query the map</a> using your earlier strings)
                </br>
                I'm left wondering, shouldn't the Go runtime then not do it for me/you by default? Anytime the runtime sees a map that is
                larger than X and the keys to that map contains pointers, the runtime inlines(for lack of a better term)
                that map into one whose keys are ints(or whatever) and does the string->ints hashing for you without you
                even noticing.</br>
                Maybe it is just my naivety...</br>
                </br>
            </p>
        </div>
    </div>
</body>